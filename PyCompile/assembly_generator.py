class AssemblyGenerator:
    def generate(self, ir_nodes):
        assembly_code = []
        for ir_node in ir_nodes:
            assembly_code.extend(self.visit(ir_node))
        return '\n'.join(assembly_code)
    
    
    def visit(self, ir_node):
        method_name = f'visit_{ir_node.type}'
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(ir_node)

    def generic_visit(self, ir_node):
        raise Exception(f'No visit_{ir_node.type} method')

    def visit_assignment(self, ir_node):
        identifier = ir_node.value
        expression_asm = self.visit(ir_node.children[0])
        return expression_asm + [f'MOV {identifier}, EAX']

    def visit_if(self, ir_node):
        condition_asm = self.visit(ir_node.children[0])
        then_asm = self.visit(ir_node.children[1])
        else_asm = self.visit(ir_node.children[2]) if len(ir_node.children) > 2 else []
        return condition_asm + ['CMP EAX, 0', 'JE ELSE_LABEL'] + then_asm + ['JMP END_IF_LABEL', 'ELSE_LABEL:'] + else_asm + ['END_IF_LABEL:']

    def visit_while(self, ir_node):
        condition_asm = self.visit(ir_node.children[0])
        body_asm = self.visit(ir_node.children[1])
        return ['WHILE_LABEL:'] + condition_asm + ['CMP EAX, 0', 'JE END_WHILE_LABEL'] + body_asm + ['JMP WHILE_LABEL', 'END_WHILE_LABEL:']

    def visit_print(self, ir_node):
        expression_asm = self.visit(ir_node.children[0])
        return expression_asm + ['CALL print_function']

    def visit_function_def(self, ir_node):
        func_name = ir_node.value
        parameters_asm = self.visit(ir_node.children[0])
        body_asm = self.visit(ir_node.children[1])
        return [f'{func_name}_LABEL:'] + parameters_asm + body_asm + ['RET']

    def visit_function_call(self, ir_node):
        func_name = ir_node.value
        arguments_asm = [self.visit(arg) for arg in ir_node.children]
        flattened_arguments_asm = [item for sublist in arguments_asm for item in sublist]
        return flattened_arguments_asm + [f'CALL {func_name}']

    def visit_binary_expression(self, ir_node):
        left_asm = self.visit(ir_node.children[0])
        right_asm = self.visit(ir_node.children[1])
        if ir_node.value == 'PLUS':
            return left_asm + ['PUSH EAX'] + right_asm + ['POP EBX', 'ADD EAX, EBX']
        elif ir_node.value == 'MINUS':
            return left_asm + ['PUSH EAX'] + right_asm + ['POP EBX', 'SUB EAX, EBX']
        elif ir_node.value == 'MUL':
            return left_asm + ['PUSH EAX'] + right_asm + ['POP EBX', 'IMUL EAX, EBX']
        elif ir_node.value == 'DIV':
            return left_asm + ['PUSH EAX'] + right_asm + ['POP EBX', 'IDIV EBX']
        else:
            raise Exception(f'Unknown binary operator {ir_node.value}')

    def visit_number(self, ir_node):
        return [f'MOV EAX, {ir_node.value}']

    def visit_identifier(self, ir_node):
        return [f'MOV EAX, {ir_node.value}']

# Example usage:
# ir_nodes = [...]  # This would be generated by the IRGenerator
# assembly_generator = AssemblyGenerator()
# assembly_code = assembly_generator.generate(ir_nodes)
# print(assembly_code)
